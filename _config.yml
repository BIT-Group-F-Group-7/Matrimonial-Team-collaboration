const express = require('express');
const app = express();
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const chai = require('chai');
const chaiHttp = require('chai-http');

mongoose.connect('mongodb://localhost/matrimonial-system', { useNewUrlParser: true, useUnifiedTopology: true });

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
  profile_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Profile' }
});

const profileSchema = new mongoose.Schema({
  user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User  ' },
  name: String,
  age: Number,
  gender: String,
  location: String
});

const matchSchema = new mongoose.Schema({
  user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User  ' },
  match_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Profile' },
  match_date: Date
});

const User = mongoose.model('User  ', userSchema);
const Profile = mongoose.model('Profile', profileSchema);
const Match = mongoose.model('Match', matchSchema);

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get('/users', (req, res) => {
  User.find().then((users) => {
    res.json(users);
  });
});

app.get('/profiles', (req, res) => {
  Profile.find().then((profiles) => {
    res.json(profiles);
  });
});

app.get('/matches', (req, res) => {
  Match.find().then((matches) => {
    res.json(matches);
  });
});

app.post('/login', (req, res) => {
  const { email, password } = req.body;
  User.findOne({ email }).then((user) => {
    if (!user) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }
    const isValidPassword = bcrypt.compareSync(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }
    const token = jwt.sign({ userId: user.id }, 'secretkey', { expiresIn: '1h' });
    res.json({ token });
  });
});

app.use((req, res, next) => {
  const token = req.headers['x-access-token'];
  if (!token) {
    return res.status(401).json({ message: 'No token provided' });
  }
  jwt.verify(token, 'secretkey', (err, decoded) => {
    if (err) {
      return res.status(401).json({ message: 'Invalid token' });
    }
    req.userId = decoded.userId;
    next();
  });
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});

chai.use(chaiHttp);

describe('Users API', () => {
  it('should return all users', (done) => {
    chai.request(app)
      .get('/users')
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('array');
        done();
      });
  });
});

describe('Profiles API', () => {
  it('should return all profiles', (done) => {
    chai.request(app)
      .get('/profiles')
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('array');
        done();
      });
  });
});

describe('Matches API', () => {
  it('should return all matches', (done) => {
    chai.request(app)
      .get('/matches')
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('array');
        done();
      });
  });
});
